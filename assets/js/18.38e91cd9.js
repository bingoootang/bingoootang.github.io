(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{280:function(s,a,n){"use strict";n.r(a);var e=n(4),t=Object(e.a)({},function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"react-同构开发（一）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-同构开发（一）","aria-hidden":"true"}},[s._v("#")]),s._v(" React 同构开发（一）")]),s._v(" "),n("p",[s._v("为什么要做同构？要回答这个问题，首先要问什么是同构。所谓同构，顾名思义就是同一套代码，既可以运行在客户端（浏览器），又可以运行在服务器端（node）。")]),s._v(" "),n("p",[s._v("我们知道，在前端的开发过程中，我们一般都会有一个"),n("code",[s._v("index.html")]),s._v(", 在这个文件中写入页面的基本内容（静态内容），然后引入JavaScript脚本根据用户的操作更改页面的内容（数据）。在性能优化方面，通常我们所说的种种优化措施也都是在这个基础之上进行的。在这个模式下，前端所有的工作似乎都被限制在了这一亩三分地之上。")]),s._v(" "),n("p",[s._v("那么同构给了我们什么样的不同呢？前面说到，在同构模式下，客户端的代码也可以运行在服务器上。换句话说，我们在服务器端就可以将不同的数据组装成页面返回给客户端（浏览器）。这给页面的性能，尤其是首屏性能带来了巨大的提升可能。另外，在SEO等方面，同构也提供了极大的便利。除此以外，在整个开发过程中，同构会极大的降低前后端的沟通成本，后端更加专注于业务模型，前端也可以专注于页面开发，中间的数据转换大可以交给node这一层来实现，省去了很多来回沟通的成本。")]),s._v(" "),n("h2",{attrs:{id:"基于react的同构开发"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基于react的同构开发","aria-hidden":"true"}},[s._v("#")]),s._v(" 基于React的同构开发")]),s._v(" "),n("p",[s._v("说了这么多，如何做同构开发呢？"),n("br"),s._v("\n这还得归功于 React提供的服务端渲染。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("ReactDOMServer.renderToString  \nReactDOMServer.renderToStaticMarkup\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[s._v("不同于 "),n("code",[s._v("ReactDom.render")]),s._v("将DOM结构渲染到页面, 这两个函数将虚拟DOM在服务端渲染为一段字符串，代表了一段完整的HTML结构，最终以html的形式吐给客户端。")]),s._v(" "),n("p",[s._v("下面看一个简单的例子：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// 定义组件 \nimport React, { Component, PropTypes } from 'react';\n\nclass News extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    var {data} = this.props;\n    return <div className=\"item\">\n      <a href={data.url}>{ data.title }</a>\n    </div>;\n  }\n}\n\nexport default News;\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br")])]),n("p",[s._v("我们在客户端，通常通过如下方式渲染这个组件：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// 中间省略了很多其他内容，例如redux等。\nlet data = {url: 'http://www.taobao.com', title: 'taobao'}\nReactDom.render(<News data={data} />, document.getElementById(\"container\"));\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("在这个例子中我们写死了数据，通常情况下，我们需要一个异步请求拉取数据，再将数据通过props传递给News组件。这时候的写法就类似于这样：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('Ajax.request({params, success: function(data) {\n  ReactDom.render(<News data={data} />, document.getElementById("container"));  \n}});\n\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("p",[s._v("这时候，异步的时间就是用户实际等待的时间。")]),s._v(" "),n("p",[s._v("那么，在同构模式下，我们怎么做呢？")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// 假设我们的web服务器使用的是KOA，并且有这样的一个controller  \nfunction* newsListController() {\n  \n  const data = yield this.getNews({params});\n\n  const data = {\n    'data': data\n  };\n  \n  this.body = ReactDOMServer.renderToString(News(data));\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("p",[s._v("这样的话，我么在服务端就生成了页面的所有静态内容，直接的效果就是减少了因为首屏数据请求导致的用户的等待时间。除此以外，在禁用JavaScript的浏览器中，我们也可以提供足够的数据内容了。")]),s._v(" "),n("h2",{attrs:{id:"什么原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么原理","aria-hidden":"true"}},[s._v("#")]),s._v(" 什么原理")]),s._v(" "),n("p",[s._v("其实，react同构开发并没有上面的例子那么简单。上面的例子只是为了说明服务端渲染与客户端渲染的基本不同点。其实，及时已经在服务端渲染好了页面，我们还是要在客户端重新使用ReactDom.render函数在render一次的。因为所谓的服务端渲染，仅仅是渲染静态的页面内容而已，并不做任何的事件绑定。所有的事件绑定都是在客户端进行的。为了避免客户端重复渲染，React提供了一套checksum的机制。所谓checksum，就是React在服务端渲染的时候，会为组件生成相应的校验和(checksum)，这样客户端React在处理同一个组件的时候，会复用服务端已生成的初始DOM，增量更新，这就是data-react-checksum的作用。")]),s._v(" "),n("p",[s._v("所以，最终，我们的同构应该是这个样子的：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// server 端  \nfunction* newsListController() {\n  \n  const data = yield this.getNews({params});\n\n  const data = {\n    'data': data\n  };\n  let news = ReactDOMServer.renderToString(News(data));\n  this.body = '<!doctype html>\\n\\\n    <html>\\\n      <head>\\\n          <title>react server render</title>\\\n      </head>\\\n      <body><div id=\"container\">' +\n          news +\n          '</div><script>var window.__INIT_DATA='+ JSON.stringify(data) +'<\/script><script src=\"app.js\"><\/script>\\\n      </body>\\\n    </html>';\n};\n\n// 客户端，app.js中  \nlet data = JSON.parse(window.__INIT_DATA__);  \nReactDom.render(<News props={data} />, document.getElementById(\"container\"));\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br")])]),n("h2",{attrs:{id:"小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结","aria-hidden":"true"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),n("p",[s._v("最近一直在做同构相关的东西，本文主要讨论react同构开发的基本原理和方式，作为一个引子，其中省去了很多细节问题。关于同构应用开发，其实有很多事情要做，比如node应用的发布、监控、日志管理，react组件是否满足同构要求的自动化检测等。这些事情都是后续要一步一步去做的，到时候也会做一些整理和积累。")])])},[],!1,null,null,null);a.default=t.exports}}]);