(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{260:function(e,o,t){"use strict";t.r(o);var r=t(4),n=Object(r.a)({},function(){var e=this,o=e.$createElement,t=e._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"node-js-基本原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-js-基本原理","aria-hidden":"true"}},[e._v("#")]),e._v(" Node.js 基本原理")]),e._v(" "),t("p",[e._v("Node.js 的"),t("a",{attrs:{href:"https://nodejs.org/en/",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方文档"),t("OutboundLink")],1),e._v("中对 Node.js 的说明是：")]),e._v(" "),t("blockquote",[t("p",[e._v("Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.")])]),e._v(" "),t("p",[e._v("可以说简单而明确的概括了 Node.js 的基本架构和工作模式。")]),e._v(" "),t("h2",{attrs:{id:"基础架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础架构","aria-hidden":"true"}},[e._v("#")]),e._v(" 基础架构")]),e._v(" "),t("p",[t("img",{attrs:{src:"/images/2017/nodejs-intro/arch.jpg",alt:"Node.js 基础架构"}})]),e._v(" "),t("p",[e._v("上图是 Node.js 的内部结构图，自底向上主要可以分成三层：最底层是 Node.js 依赖的各种库，有 V8、libuv 等；中间层是各种 Binding，也就是胶水代码；最上层是应用代码，可使用 Node.js 的各种 API。")]),e._v(" "),t("ul",[t("li",[t("p",[t("a",{attrs:{href:"https://developers.google.com/v8/",target:"_blank",rel:"noopener noreferrer"}},[e._v("V8"),t("OutboundLink")],1),t("br"),e._v("\nGoogle 开源的高性能 JavaScript 引擎，它将 JavaScript 代码转换成机器码，然后执行，因此速度非常快。V8 以 C++ 语言开发，Google 的 Chrome 浏览器正是使用的 V8 引擎。")])]),e._v(" "),t("li",[t("p",[t("a",{attrs:{href:"https://github.com/libuv/libuv",target:"_blank",rel:"noopener noreferrer"}},[e._v("libuv"),t("OutboundLink")],1),t("br"),e._v("\nlibuv 以 C 语言开发，内部管理着一个线程池。在此基础之上，提供事件循环（Event Loop）、异步网络 I/O、文件系统 I/O等能力。")])]),e._v(" "),t("li",[t("p",[t("a",{attrs:{href:"https://nodejs.org/en/docs/meta/topics/dependencies/",target:"_blank",rel:"noopener noreferrer"}},[e._v("其他底层依赖库"),t("OutboundLink")],1),t("br"),e._v("\n如 "),t("a",{attrs:{href:"http://c-ares.haxx.se/",target:"_blank",rel:"noopener noreferrer"}},[e._v("c-ares"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"https://www.openssl.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("crypto (OpenSSL)"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"https://github.com/nodejs/http-parser",target:"_blank",rel:"noopener noreferrer"}},[e._v("http-parser"),t("OutboundLink")],1),e._v(" 以及 "),t("a",{attrs:{href:"http://zlib.net/",target:"_blank",rel:"noopener noreferrer"}},[e._v("zlib"),t("OutboundLink")],1),e._v("。这些依赖提供了对系统底层功能的访问，包括网络、压缩、加密等。")])])]),e._v(" "),t("p",[e._v("Node.js 底层的依赖库，有的以 C 语言开发，有的以 C++ 语言开发，如何让应用代码（JavaScript）能够与这些底层库相互调用呢？这就需要中间层的 Binding 来完成。Binding 是一些胶水代码，能够把不同语言绑定在一起使其能够互相沟通。在 Node.js 中，binding 所做的就是把 Node.js 那些用 C/C++ 写的库接口暴露给 JS 环境。")]),e._v(" "),t("p",[e._v("中间层中，除了 Binding，还有 Addon。Binding 仅桥接 Node.js 核心库的一些依赖，如果你想在应用程序中包含其他第三方或者你自己的 C/C++ 库的话，需要自己完成这部分胶水代码。你写的这部分胶水代码就称为 Addon。本质上都是完成桥接的作用，使得应用与底层库能够互通有无。")]),e._v(" "),t("p",[e._v("应用层的代码，就不必多言了，我们开发的应用、npm 安装的包都运行在这里。")]),e._v(" "),t("h2",{attrs:{id:"事件循环-event-loop-与工作线程池（worker-thread-pool）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件循环-event-loop-与工作线程池（worker-thread-pool）","aria-hidden":"true"}},[e._v("#")]),e._v(" 事件循环 (event loop) 与工作线程池（worker thread pool）")]),e._v(" "),t("p",[e._v("官方文档中说，Node.js 使用事件驱动、非阻塞的 I/O 工作模型，从而使得 Node.js 非常的轻量和高效。")]),e._v(" "),t("p",[e._v("要想理解清楚这句话，需要从下面的工作流程图开始。"),t("br"),e._v(" "),t("img",{attrs:{src:"/images/2017/nodejs-intro/nodejs.png",alt:"Node.js 系统"}})]),e._v(" "),t("p",[e._v("在这张图中，重点部分就是右侧的事件循环和工作线程池了，它也是 Node.js 事件驱动、非阻塞 I/O 工作模型的核心。")]),e._v(" "),t("p",[e._v("一个 Node.js 应用启动时，会先启动事件循环，V8 引擎会执行应用代码，在这个过程中，应用代码可能发起异步 API 请求、设置定时器或者直接调用 "),t("code",[e._v("process.nextTick()")]),e._v(" 方法，在执行完应用代码（main module）后，Node.js 开始事件循环。")]),e._v(" "),t("p",[e._v("下图展示了事件循环的各个阶段。"),t("br"),e._v(" "),t("img",{attrs:{src:"/images/2017/nodejs-intro/event-loop.jpg",alt:"IMAGE"}})]),e._v(" "),t("p",[e._v("每个阶段都有一个 FIFO 队列来执行回调。当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列中的所有回调都已经执行完或者达到了每轮可执行的最大回调数。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段，如此往复。")]),e._v(" "),t("p",[e._v("Node.js 的事件循环总共有6个阶段：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("定时器（timers）\n该阶段执行由 "),t("code",[e._v("setTimeout()")]),e._v(" 和 "),t("code",[e._v("setInterval()")]),e._v(" 设置的回调函数。计时器指定可执行所提供回调的阈值，而不是用户希望其执行的确切时间。定时器回调将尽可能早地运行，因为它们可以在指定的时间间隔后进行调度。但是，操作系统调度或其它回调的运行可能会延迟它们。实际上，定时器阶段执行的时机是由 poll 阶段确定的。")])]),e._v(" "),t("li",[t("p",[e._v("挂起的回调函数（pending callbacks）\n此阶段针对某些系统操作执行回调。比如，如果 TCP 套接字在尝试连接时接收到 ECONNREFUSED，而某些 *nix 的系统希望等待报告错误。这将被排队以在挂起的回调阶段执行。")])]),e._v(" "),t("li",[t("p",[e._v("idle,prepare\n仅供内部使用。")])]),e._v(" "),t("li",[t("p",[e._v("轮询（poll）\n轮询阶段有两个重要的功能：计算应该阻塞和轮询 I/O 的时间和处理轮询队列里的事件。")]),e._v(" "),t("p",[e._v("当事件循环进入轮询阶段且没有计划计时器时 ，将发生以下两种情况之一：")]),e._v(" "),t("ol",[t("li",[e._v("如果轮询队列不是空的 ，事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制。")]),e._v(" "),t("li",[e._v("如果 轮询 队列 是空的 ，还有两件事发生：\n"),t("ol",[t("li",[e._v("如果脚本中使用了 "),t("code",[e._v("setImmediate()")]),e._v("，则事件循环将结束轮询阶段，并继续到检查阶段以执行这些计划脚本。")]),e._v(" "),t("li",[e._v("如果脚本中没有使用 "),t("code",[e._v("setImmediate()")]),e._v("，则事件循环将等待回调添加到队列中，然后立即执行。")])])])]),e._v(" "),t("p",[e._v("一旦轮询队列为空，事件循环将检查已达到时间阈值的定时器。如果一个或多个计时器已准备就绪，则事件循环将绕回定时器阶段以执行这些定时器的回调。")])]),e._v(" "),t("li",[t("p",[e._v("检查（check）\n执行 "),t("code",[e._v("setImmediate()")]),e._v(" 设置的回调。如果轮询阶段变为空闲状态，并且脚本中使用了 "),t("code",[e._v("setImmediate()")]),e._v("，则事件循环可能继续到 检查阶段而不是等待。\n"),t("code",[e._v("setImmediate()")]),e._v(" 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个 libuv API 来安排回调在轮询阶段完成后执行。\n通常，在执行代码时，事件循环最终会命中轮询阶段，等待传入连接、请求等。但是，如果回调已计划为 "),t("code",[e._v("setImmediate()")]),e._v("，并且轮询阶段变为空闲状态，则它将结束并继续到检查阶段而不是等待轮询事件。")])]),e._v(" "),t("li",[t("p",[e._v("关闭的回调函数（close callbacks）\n执行关闭回调。比如： "),t("code",[e._v("socket.on('close', ...)")]),e._v("。如果套接字或处理函数突然关闭（例如 "),t("code",[e._v("socket.destroy()")]),e._v("），则 "),t("code",[e._v("'close'")]),e._v(" 事件将在这个阶段发出。否则它将通过 "),t("code",[e._v("process.nextTick()")]),e._v(" 发出。")])])]),e._v(" "),t("blockquote",[t("p",[e._v("还需要提到的一点是 "),t("code",[e._v("process.nextTick()")]),e._v("。"),t("code",[e._v("process.nextTick()")]),e._v(" 产生的回调函数保存在一个叫做 "),t("code",[e._v("nextTickQueue")]),e._v(" 的队列中，不在上面任何一个阶段的队列里面。当当前操作完成后，"),t("code",[e._v("nextTickQueue")]),e._v(" 中的回调函数会立即被执行，不管事件循环处在哪个阶段。也就是说，在 "),t("code",[e._v("nextTickQueue")]),e._v(" 中的回调函数被执行完毕之前，事件循环不会往前推进。")])]),e._v(" "),t("p",[e._v("要想实现非阻塞的 I/O，仅仅靠事件循环并不能完成，还需要搭配工作线程池。换句话说，Node.js 通过事件循环机制（初始化和回调）的方式运行 JavaScript 代码，并且提供了一个线程池处理诸如文件 I/O 等高成本的任务。Node.js 有一个事件轮询线程负责任务编排，和一个专门处理繁重任务的工作线程池。")]),e._v(" "),t("p",[e._v("Node.js 的工作线程池通过 libuv 来实现，它对外提供了一个通用的任务处理 API。工作线程池处理的都是“高成本”任务，比如 I/O 密集型任务，CPU 密集型任务等。"),t("br"),e._v("\n比如，当应用需要读取一个文件时，如果在事件循环线程中直接读取会阻塞后续的事件处理，饿死事件循环，导致程序性能下降。如果放到工作线程池里，由工作线程来完成，在文件读取完成时通知事件循环进行处理，则会大大提高程序处理效率和性能。")]),e._v(" "),t("p",[e._v("事实上，事件轮询线程会持有一堆文件描述符，当操作系统确定某个文件描述符发生变化，事件轮询线程将把它转换成合适的事件，然后出发该事件对应的回调。当遇到高成本任务时，事件循环线程会通过 C++  binding 向工作线程池提交一个任务。而工作线程使用任务队列来管理要被处理的任务。一个工作线程从这个队列中取出一个任务，开始处理它。当完成之后这个工作线程向事件循环线程中发出一个“至少有一个任务完成了”的消息。")]),e._v(" "),t("p",[e._v("理解了事件循环和工作线程池的工作原理后，就不难发现 Node.js 轻量级和高效的原因。相对于类似 Apache 这种“一个客户端连接一个线程”的系统来说，Node.js 只使用少量的线程处理大量的客户端请求，减少了线程切换的开销，使用非阻塞 I/O 极大的提高了应用的运行效率（吞吐率）。需要注意的是，使用 Node.js 并不能保证应用就一定高效，应用仍然需要合理的设计，不同任务之间公平合理的调度，才能保证应用的高效。")]),e._v(" "),t("p",[t("strong",[e._v("参考文档")])]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/",target:"_blank",rel:"noopener noreferrer"}},[e._v("The Node.js Event Loop, Timers, and process.nextTick()"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://nodejs.org/en/docs/guides/dont-block-the-event-loop/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Don't Block the Event Loop (or the Worker Pool)"),t("OutboundLink")],1)])])])},[],!1,null,null,null);o.default=n.exports}}]);