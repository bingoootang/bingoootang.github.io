(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{287:function(e,t,r){"use strict";r.r(t);var a=r(4),n=Object(a.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"再看-redux"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#再看-redux","aria-hidden":"true"}},[e._v("#")]),e._v(" 再看 Redux")]),e._v(" "),r("p",[e._v("最近在公司里推动前端技术栈统一的事情，借着机会把 Redux 相关的文档又过了一遍，重新梳理了相关的概念，整理如下。")]),e._v(" "),r("blockquote",[r("p",[e._v("本文不会对 Redux 的实现细节做过多讨论，在这方面有兴趣的同学可以参考我之前的一篇"),r("router-link",{attrs:{to:"/2016/05/16/redux-first-sight.html"}},[e._v("文章")]),e._v("。")],1)]),e._v(" "),r("p",[e._v("我们知道，React 只专注于解决视图层的问题，把数据层的问题留给了开发者。在 Facebook 推出 "),r("a",{attrs:{href:"https://facebook.github.io/flux/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Flux"),r("OutboundLink")],1),e._v(" 之后，引发了社区很多的实现。"),r("a",{attrs:{href:"https://redux.js.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redux"),r("OutboundLink")],1),e._v(" 的核心思想就是来自于 Flux。")]),e._v(" "),r("p",[e._v("Redux 给我们预先定义了三个核心概念，那就是 State、Action、Reducer，这三个概念构成了 Redux 的基础。")]),e._v(" "),r("ul",[r("li",[e._v("State 保存着应用的状态，或者说是数据。")]),e._v(" "),r("li",[e._v("Action 描述一个动作，这个动作可以来源于用户，可以来源于事件，总之，Action 将会导致 State 的改变。")]),e._v(" "),r("li",[e._v("Reducer 根据 Action 来对 State 进行更改。")])]),e._v(" "),r("p",[e._v("有了这三个概念，我们就可以大概窥探到了 Redux 的工作原理。State 就是简单的 JavaScript 对象，视图层发起一个 Action，表示发生了一些事情（用户操作、事件等），需要对 State 进行一些改变。Reducer 获得 Action 之后，根据 Action 的类型，对 State 进行改变，完成 State 的更新。"),r("br"),e._v("\n由此可见，Redux 其实就是一个状态机，Action 用来描述这个状态机将要到达哪个状态，而这个状态是由 Reducer 计算出来的。")]),e._v(" "),r("p",[e._v("那么，怎么来保证这个状态机能顺利的运行呢？我们会不会因为不小心直接修改了全局的状态，导致这个状态机奔溃了呢？我们又如何让 Reducer 处理 Action 并更新 State 呢？"),r("br"),e._v("\nRedux 提出了三个指导原则来约束我们的代码，避免我们的直接操作全局对象、各自管理数据等不规范行为，来保证系统的正常运行。")]),e._v(" "),r("ul",[r("li",[e._v("单一数据源，即整个应用的状态都保存在一棵对象树中。")]),e._v(" "),r("li",[e._v("State 是只读的，只能通过 Action 来修改 State。")]),e._v(" "),r("li",[e._v("所有对 State 的改变都需要通过纯函数来完成。")])]),e._v(" "),r("p",[e._v("通过这三个指导原则，Redux 成功杜绝了主观上不规范代码的产生。但是，光有这三个基本原则只能指导我们如何去管理代码，并不能帮助我们方便的开发应用。前面提到的第二个问题依然没有解决。为此，Redux 又提供了一个 Store 对象，将上面的概念和原则粘合在一起，并提供给我们。我们只需要通过这个 Store 对象来发起 Action，Store 会调用我们预先定义好的 Reducer 来处理 Action，最后 Store 还会将新的 State 替代之前的 State。")]),e._v(" "),r("p",[e._v("有了 Store 对象，我们眼前一下清晰了起来。整个 Redux 的数据流也就慢慢浮现出来了。"),r("br"),e._v(" "),r("img",{attrs:{src:"/images/2016/redux/redux.jpg",alt:"redux data flow"}})]),e._v(" "),r("ol",[r("li",[e._v("首先，我们通过 store.dispatch 来发起一个 action")]),e._v(" "),r("li",[e._v("store 调用 reducer 处理这个 action")]),e._v(" "),r("li",[e._v("reducer 更新数据")]),e._v(" "),r("li",[e._v("store 保存新的 state")])]),e._v(" "),r("p",[e._v("有了数据流，有了 Store 对象，我们似乎可以愉快的开发应用了，不免感叹一句，前端开发 so easy。但是，我们貌似忽略了很多东西，比如错误处理，日志记录，异步请求等，这些通过 Store 根本做不了，我们还是需要在视图层里来做。这是不可接受的。")]),e._v(" "),r("p",[e._v("Redux 又给我们提供了中间件的概念。中间件为开发者提供了一个在dispatch action 之后到 action 到达 reducer 之前的第三方扩展点。我们通过编写中间件来完成诸如日志记录、错误处理、异步请求的工作。关于中间件的细节实现，这里不做讨论，感兴趣的同学可以参考"),r("a",{attrs:{href:"https://redux.js.org/docs/advanced/Middleware.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方文档"),r("OutboundLink")],1),e._v("或者本文开头的那篇文章。")]),e._v(" "),r("p",[e._v("到此，Redux 的核心内容就梳理完了。那我们怎么让 Redux 跟 React 很好的结合起来，助力我们的应用开发呢？不难想到，我们可以通过一些胶水代码来将 Redux 和 React 结合起来。但是每个人都自己写一套的话，又显得非常繁琐，而且这些胶水代码各有各的风格，各有各的味道。"),r("br"),e._v("\nReact 官方给我们提供了 "),r("a",{attrs:{href:"https://github.com/reactjs/react-redux",target:"_blank",rel:"noopener noreferrer"}},[e._v("react-redux"),r("OutboundLink")],1),e._v(" 这个胶水代码包，并封装了非常精简的 API。"),r("br"),e._v("\n终于，我们连最后的胶水代码也省了，可以完全把精力投入到应用开发中来了。")]),e._v(" "),r("p",[e._v("原本，写到这里，Redux 相关的整理就已经初步结束了，但是 "),r("a",{attrs:{href:"https://redux-saga.js.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("redux-saga"),r("OutboundLink")],1),e._v(" 目前在我们团队里大规模使用，且 redux-saga 是 Redux 的一个中间件，因此，关于 redux-saga 的梳理也一并整理在这里。")]),e._v(" "),r("p",[e._v("redux-saga 是 Redux 应用的又一个副作用模型。通过 "),r("a",{attrs:{href:"http://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Sagas"),r("OutboundLink")],1),e._v(" 把应用所有的副作用搜集到一个统一的地方，由 Sagas 来负责策划统筹合成和异步操作。\n这样的话，整个应用开发除了视图层以外，我们只需要关注两个方面：")]),e._v(" "),r("ul",[r("li",[e._v("Reducers 负责处理action的state转换。")]),e._v(" "),r("li",[e._v("Sagas 负责策划统筹合成和异步操作。")])]),e._v(" "),r("p",[e._v("redux-saga 通常会被拿来和 "),r("a",{attrs:{href:"https://github.com/gaearon/redux-thunk",target:"_blank",rel:"noopener noreferrer"}},[e._v("redux-thunk"),r("OutboundLink")],1),e._v(" 进行比较。我们知道，redux-thunk 给我们提供了发起异步 Action 的能力，让我们可以更加方便的进行异步请求。但是，当我们应用变得复杂，需要对异步流程进行控制（组合、嵌套），操作浏览器存储，甚至有时候需要取消已经发起的异步请求时，redux-thunk 能给我提供的帮助就非常有限了，甚至会把我们带入万恶的"),r("a",{attrs:{href:"https://en.wiktionary.org/wiki/callback_hell",target:"_blank",rel:"noopener noreferrer"}},[e._v("回调地狱"),r("OutboundLink")],1),e._v("中。"),r("br"),e._v("\nredux-saga 致力于通过 Sagas 的方式，让我们更好的管理应用的副作用（side effects，比如异步数据请求、操作浏览器存储等）。"),r("br"),e._v("\nredux-saga 将等待一个 Action 然后触发 State 更新、调用远程服务、调用浏览器 API 等统一抽象成 Effect，并允许通过常见的控制流程（if/else, while, for, try/catch）来组合这些 Effect。而且，Safas 本身也是 Effect，可以与其他 Effect 相组合，也可以被内部其他 Saga 调用。通过上面这些抽象，redux-saga 给我们提供了丰富的子程序和"),r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Structured_programming",target:"_blank",rel:"noopener noreferrer"}},[e._v("结构化程序设计"),r("OutboundLink")],1),e._v("的能力。这样的能力正是我们进行复杂业务开发所需要的。比如，用户报名一个活动，需要先登录，再填写报名信息。这个功能的开发需要登录模块、活动模块的共同参与，借助于 redux-saga 提供的子程序和 Saga 组合的能力，我们可以方便的在用户点击报名按钮的那个动作中，自然的完成这些功能，而不再需要在视图层层中添加多余的判断，发起不同的 Action 了。"),r("br"),e._v("\n借助于 Generator 函数的能力，redux-saga 给我们提供了真正的同步方式书写异步代码的能力，从此告别了回调函数的困扰。另外，Sagas 还是可取消的，我们可以主动的取消（cancel）一个正在运行的 saga。这在搜索场景中是非常实用的功能。我们可以通过主动取消异步操作来避免用户输入过程中产生的数据请求对服务器造成的冲击。"),r("br"),e._v("\n除了以上种种以外，redux-saga 还有一个非常耀眼的特性就是对写测试非常友好。我们不再需要通过大量的 mock 就可以测试到核心的业务逻辑中。从此，异步数据请求、浏览器 API 操作等对于我们的测试代码来说将不再是黑盒。")]),e._v(" "),r("p",[e._v("到这里，在 React 技术栈中关于 Redux 整理就基本结束了。本文没有详细的实现原理分析，也没有相关的代码样例，更多的是从理论结构上来对 Redux 相关内容进行一个梳理，为的是在我们写代码的同时，能在理论结构层面上对 Redux 有一个全面的认识。")])])},[],!1,null,null,null);t.default=n.exports}}]);