(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{286:function(t,n,s){"use strict";s.r(n);var a=s(4),e=Object(a.a)({},function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"从-react-redux-connect-看如何编写-hoc（一）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从-react-redux-connect-看如何编写-hoc（一）","aria-hidden":"true"}},[t._v("#")]),t._v(" 从 React-Redux connect 看如何编写 HOC（一）")]),t._v(" "),s("p",[t._v("HOC（Higher-Order Component），中文译作高阶组件，是基于 React 的原生组合特性提炼出来的组件复用模式。准确的说，一个高阶组件就是一个接受一个组件作为参数并返回一个新的组件的函数。其形式类似于下面这段代码：")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" EnhancedComponent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("higherOrderComponent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("WrappedComponent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("我们知道，在 React 中，组件是最基本的复用单元。但是在开发过程中，我们经常发现，两个不同的组件通常会有极其相似的结构，仅仅只是调用的接口不同。比如，页面中的两个组件分别监听两个事件，并在接收到事件时去服务端拉取数据。在开发这两个的时候，我们需要在组件中分别写一段相同的添加事件监听、删除事件监听、去服务端拉取数据等代码逻辑。如果其他页面也有相似的结构，但是监听事件和调用接口都不一样，我们就需要再次实现同样结构的组件。这其实是一种没有意义的重复，热爱思考的程序员是不愿意干这种纯体力劳动的，所以有了高阶组件。我们把添加、删除事件监听，拉取数据等逻辑放到高阶组件中，而真实的组件只需要接收数据并完成渲染就可以了。")]),t._v(" "),s("blockquote",[s("p",[t._v("上面这个问题，在软件工程中有个专有的名词，叫横切关注点（"),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Cross-cutting_concern",target:"_blank",rel:"noopener noreferrer"}},[t._v("Cross-Cutting Concerns"),s("OutboundLink")],1),t._v("），高阶组件是我们在 React 应用开发过程中解决这个问题的一个很好的模式。")])]),t._v(" "),s("p",[t._v("任何一个模式都不是万能的，高阶组件也有一些使用约束。")]),t._v(" "),s("p",[t._v("高阶组件不提倡以下做法：")]),t._v(" "),s("ol",[s("li",[t._v("在高阶组件中修改原始组件，比如修改了生命周期方法。"),s("br"),t._v("\n首先，如果修改了原始组件，会导致原始组件不能单独复用。其次，如果一个组件被多个高阶组件使用，可能会造成复写，比如同时修改了生命周期方法。")]),t._v(" "),s("li",[t._v("在组件的 render 方法中使用高阶组件。\nReact 会判断两次 render 返回的实例是否相同，如果相同则会递归执行 React Diff 算法来更新实例，如果不同，则直接将就得实例 unmount 掉。如果在 render 方法中使用高阶组件，不仅会造成可能的性能问题，还会造成所有子组件状态的丢失。")])]),t._v(" "),s("p",[t._v("高阶组件提倡以下做法：")]),t._v(" "),s("ol",[s("li",[t._v("将与高阶组件的实现不相关的 props 传递给被包装的组件。"),s("br"),t._v("\n这样的话，在使用高阶组件的时候就和使用原始组件是一样的，使用者对于高级组件的存在是无感的。")]),t._v(" "),s("li",[t._v("最大限度的使用组合。\n我们在开发高阶组件的时候，通常都需要额外的支持一些配置参数，这时，高阶组件的形式可能是：")])]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" CommentWithRelay "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Relay"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createContainer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Comment"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" config"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Relay.createContainer 是一个高阶组件")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("此时如果我们需要组合使用多个高阶组件时，我们就需要多次调用类似于上面的逻辑。社区有很多类似于 "),s("a",{attrs:{href:"https://redux.js.org/docs/api/compose.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redux Compose"),s("OutboundLink")],1),t._v(" 的方法来帮我们做这些事情，但是这些方法的签名都是类似于 "),s("code",[t._v("Component => Component")]),t._v(" 的方式，所以，我们的高阶组件的定义方式建议定义成")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ConnectedComment "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("connect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("commentSelector"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" commentActions"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("CommentList"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("而这也正是 React-Redux 中 connect 方法的签名。"),s("br"),t._v("\n这样的话，我们就可以轻松的通过 compose 工具函数完成多个高阶组件的组合了。")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Instead of doing this...")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" EnhancedComponent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("withRouter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("connect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("commentSelector"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("WrappedComponent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ... you can use a function composition utility")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// compose(f, g, h) is the same as (...args) => f(g(h(...args)))")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" enhance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compose")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// These are both single-argument HOCs")]),t._v("\n  withRouter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("connect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("commentSelector"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" EnhancedComponent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("enhance")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("WrappedComponent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("ol",{attrs:{start:"3"}},[s("li",[t._v("给高阶组件添加 "),s("code",[t._v("displayName")]),t._v(" 属性"),s("br"),t._v("\n添加 "),s("code",[t._v("displayName")]),t._v(" 属性后，通过 "),s("a",{attrs:{href:"https://github.com/facebook/react-devtools",target:"_blank",rel:"noopener noreferrer"}},[t._v("react-devtools"),s("OutboundLink")],1),t._v(" 等调试工具调试时就可以清楚的看到组件名，提升调试效率。")]),t._v(" "),s("li",[t._v("组件静态方法必须要拷贝到高阶组件中。"),s("br"),t._v("\n保持组件接口的一致性。")])]),t._v(" "),s("p",[t._v("除了以上提到的以外，在使用高阶组件的时候，我们还需要注意，高阶组件不会将 "),s("code",[t._v("refs")]),t._v(" 传递给被包装的组件。如果要实现在高阶组件中能拿到被包装组建的 refs，则可以在高阶组件中实现被包装组件的 refs 绑定函数，并将它通过 props 传递给被包装的组件。")])])},[],!1,null,null,null);n.default=e.exports}}]);