(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{284:function(e,r,v){"use strict";v.r(r);var _=v(4),t=Object(_.a)({},function(){var e=this,r=e.$createElement,v=e._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"复杂应用的前端开发模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复杂应用的前端开发模式","aria-hidden":"true"}},[e._v("#")]),e._v(" 复杂应用的前端开发模式")]),e._v(" "),v("p",[e._v("面对日益复杂的前端应用，状态管理已经成了应用开发过程中越来越让人头疼的问题。另外，在多人协作的大型项目中，模块间的数据交换、组件复用经常会造成很大的沟通成本。因此，除了功能实现以外，从整个应用的角度看，如何更高效的完成应用开发已经成为了我们不得不思考的问题。")]),e._v(" "),v("p",[e._v("随着 React 的兴起，以及 Redux 的流行，单向数据流的理念已经深入人心。单向数据流帮助我们对应用状态进行集中管理，并规定了数据修改的规范方式，避免了应用状态随着应用规模的不断变大而混乱的问题。但是在基于单向数据流理念的开发过程中，我们发现，虽然数据都集中管理了，但是引起数据修改的操作依然分散在各个者组件中，组件可以直接触发 action 来修改数据。当应用规模较小的时候，这么做方便快捷，也不会有什么问题。但是，随着应用规模的不断扩大，每个页面的业务含义不同，对数据的诉求也不同，直接在组件中触发 action 限制了组件的复用性，同时也会让组件包含太多的业务逻辑，导致视图层的逻辑变得复杂，开发注意力容易分散，常常顾此失彼，定位问题的成本越来越高。")]),e._v(" "),v("p",[e._v("笔者最近开发了一个内部使用的项目管理系统，就遇到了上面提到的种种问题。在解决问题的过程中做了一些思考和推演，整理如下。")]),e._v(" "),v("p",[e._v("通常，一个前端应用，排除服务端的数据接口，可以用下面这张图完整的展示出来："),v("br"),e._v(" "),v("img",{attrs:{src:"/images/2018/state-management-based-on-url/app-data-flow.jpg",alt:"IMAGE"}})]),e._v(" "),v("blockquote",[v("p",[e._v("图中借鉴了 dva 的一些理念（dva 正是本次项目的技术框架选型）。")])]),e._v(" "),v("p",[e._v("在开发过程中，尤其是大型项目的开发过程中，我们需要将开发注意力集中在某些重要的节点上，忽略次要因素的干扰。因此，第一步要做的是")]),e._v(" "),v("p",[v("strong",[e._v("1. 业务逻辑与页面细节分离")])]),e._v(" "),v("p",[e._v("用户在使用应用的时候，必然要先在浏览器的地址栏中输入应用的访问地址，可以是一个域名，也可以是一个具体的 url，然后在应用加载完成后进行操作。在应用中，我们会在相关页面的切换入口埋入路由，用户点击这些路由进入到相关的页面。因此，路由与页面是一一对应的关系，通常情况下，可以将路由认为是页面的 id。\n因此，在面对复杂应用开发时候，我们可以先按功能模块划分具体的路由，比如在项目管理系统中，路由可以划分为：")]),e._v(" "),v("ul",[v("li",[e._v("/project")]),e._v(" "),v("li",[e._v("/document")]),e._v(" "),v("li",[e._v("/user")])]),e._v(" "),v("p",[e._v("每个顶级路由下又可以划分许多子路由，比如 "),v("code",[e._v("/project")]),e._v(" 下可以划分：")]),e._v(" "),v("ul",[v("li",[e._v("/project/:projectId/requirement")]),e._v(" "),v("li",[e._v("/project/:projectId/report")])]),e._v(" "),v("p",[v("code",[e._v("requirement")]),e._v(" 和 "),v("code",[e._v("report")]),e._v(" 还可以划分更细的路由。")]),e._v(" "),v("p",[e._v("路由确定好之后，我们需要确定每个路由需要的数据和页面逻辑。"),v("br"),e._v("\n一般情况下，业务逻辑的划分跟路由划分有着极强的关联关系，因此，业务数据可以方便的根据路由来组织。借鉴 dva 中 model 的概念，我们为每个业务模块定义一个 model。"),v("br"),e._v("\n至于页面逻辑，为了避免业务逻辑过于分散，我们将业务逻辑统一收缩到某一些顶层组件中，这些顶层组件与 redux 紧密结合，作为这个业务模块的容器组件，在这个容器组件以下，全部都是展示性组件。展示性组件通过对外暴露通用的数据修改接口，以完成数据修改动作。这其实就是"),v("a",{attrs:{href:"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0",target:"_blank",rel:"noopener noreferrer"}},[e._v("展示组件和容器组件"),v("OutboundLink")],1),e._v("的思路。")]),e._v(" "),v("p",[e._v("通过路由划分，我们可以对业务数据进行有条理的梳理和组织。通过展示组件和容器组件，我们可以把数据修改逻辑进行集中管理，同时将通用的展示逻辑进行组件抽取，提升组件复用率。")]),e._v(" "),v("p",[v("strong",[e._v("2. 数据更新")])]),e._v(" "),v("p",[e._v("完成业务逻辑与页面细节分离之后，我们需要关注的重点是如何进行数据更新。这里的数据更新分为两点，主动更新和被动更新。")]),e._v(" "),v("p",[e._v("所谓主动更新就是当路由切换时，我们需要主动拉取业务数据，以支撑业务模块的首次展示。通常情况下，我们需要添加路由切换的监听逻辑，根据变化的路由调用接口拉取数据。在本次开发过程中， dva 的 model 提供了 subscriptions 订阅配置，我们可以在这个里面添加路由变化的监听，拉取具体的业务数据。")]),e._v(" "),v("p",[e._v("被动更新就是响应用户操作的数据更新，这可能涉及到调用服务端接口，也可能仅仅是简单额计算动作。redux 极其生态很好的帮我们解决数据被动更新的问题。纯数据计算通过 reducer 即可完成，调用服务端接口可以通过异步中间件完成。常用的中间件有 redux-thunk 和 redux-saga。由于 redux-saga 提供了更加强大的业务处理能力，因此我们选择通过 redux-saga 来完成异步数据获取及过程中相关的业务操作。")]),e._v(" "),v("p",[e._v("说到这里，貌似基本可以保证应用正常开发了。但是应用常常存在不同业务模块之间数据共用的情况，因此前面提到的为每个业务模块建立一个独立 model 的方式会造成数据冗余，会给数据更新造成困难。")]),e._v(" "),v("p",[v("strong",[e._v("3. 业务模型的抽象")])]),e._v(" "),v("p",[e._v("为了解决这个问题，我们需要对业务模型进行一定的抽象。由于跟业务强相关，因此社区内也没有通用的解决方案，只能借助于基本的软件设计方法和原则，借鉴面向对象基本的组合、继承思路，对业务模型进行抽象。"),v("br"),e._v("\n这里笔者也在探索过程中，不过可以简单说明一下思路。")]),e._v(" "),v("p",[e._v("由于 model 跟业务数据是强相关的，同时 model 又需要对页面展示进行支撑，那么 model 势必要进行分层。即划分一层纯业务 model，保存业务数据。再划分一层视图 model，负责页面数据的组织和响应页面操作以对业务数据进行修改。这样，每个路由对应一个视图 model，视图 model 底层共用若干个业务 model，视图 model 作为业务 model 的代理提供视图支撑。")]),e._v(" "),v("p",[e._v("前面业务逻辑与页面细节分离一节中说到，通过容器组件包装业务逻辑，展示组件展示数据，这正是天然的视图 model 的模型。不妨将视图 model 换一个名字，local state，容器组件的本地状态。这样，业务 model 保存原始的业务数据，容器组件对业务 model 的数据进行再处理，之后再给展示组件绘制视图。")]),e._v(" "),v("p",[e._v("还有一个问题没有解决，那就是，不同视图对业务数据的格式要求不同，而原始的业务数据往往是带有嵌套的 json 数据（服务端接口返回），需要在容器组件中进行复杂的数据处理。如果涉及到大量的列表操作，可能对应用性能产生影响。好在社区已经有了解决方案，那就是通过 "),v("a",{attrs:{href:"https://github.com/paularmstrong/normalizr",target:"_blank",rel:"noopener noreferrer"}},[e._v("normalizr"),v("OutboundLink")],1),e._v(" 来进行序列化。")]),e._v(" "),v("p",[e._v("完成以上三点，相信对于一个复杂应用来说，条理已经非常清楚，同时为新功能的添加预留了足够的空间，毕竟添加新模块就是添加新的路由和对应的 model。在定位问题的时候，我们也可以根据问题的表现快速定位到问题可能发生的节点，快速响应。")])])},[],!1,null,null,null);r.default=t.exports}}]);