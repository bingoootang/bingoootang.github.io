(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{255:function(t,s,a){"use strict";a.r(s);var e=a(4),n=Object(e.a)({},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-native-中的长度、字号大小等适配方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-native-中的长度、字号大小等适配方案","aria-hidden":"true"}},[t._v("#")]),t._v(" React Native 中的长度、字号大小等适配方案")]),t._v(" "),a("p",[t._v("熟悉 React Native 的同学应该都知道，RN 中所有长度大小都是没有单位的（unitless）。但是设计师给的稿子一般都是按照 iPhone6 或者更高版本给的，有着固定的宽度，而且有时候是 375px，有时候是 750px。那么，怎样才能保证在各个设备上更好的展示页面效果呢？")]),t._v(" "),a("blockquote",[a("p",[t._v("关于这块的文章说明网上有很多，写作本文的目的是进行一个系统的说明，并提供一个可靠的解决方案。")])]),t._v(" "),a("p",[t._v("移动操作系统为了适配不同屏幕尺寸和密度的设备，会将应用的用户界面调整为适应其显示的屏幕，也就是会对用户界面进行缩放和大小调整。"),a("br"),t._v("\n在进一步说明之前，我们先了解一些基本概念：")]),t._v(" "),a("ul",[a("li",[t._v("屏幕尺寸：按屏幕对角测量的实际物理尺寸。")]),t._v(" "),a("li",[t._v("屏幕密度：屏幕物理区域中的像素量；通常称为 dpi（每英寸点数）。")]),t._v(" "),a("li",[t._v("分辨率：屏幕上物理像素的总数。")]),t._v(" "),a("li",[t._v("密度无关像素(dp)：在定义 UI 布局时应使用的虚拟像素单位，用于以密度无关方式表示布局维度或位置。")])]),t._v(" "),a("h2",{attrs:{id:"密度独立像素（density-independent-pixels-dp）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#密度独立像素（density-independent-pixels-dp）","aria-hidden":"true"}},[t._v("#")]),t._v(" 密度独立像素（density-independent pixels, dp）")]),t._v(" "),a("p",[t._v("如果我们采用固定的绝对像素进行页面布局的话，在不同分辨率的设备上我们页面的大小会不一样。比如，对于 640px 的宽度，在 iPhone4(640×960) 上就已经撑满了整个屏幕，但是在 iPhone6(750x1334) 上却不能，这当然是不可接受的。好在操作系统为我们提供了密度独立像素，类似于在"),a("router-link",{attrs:{to:"/blog/2018/04/16/website-layout-1/"}},[t._v("《聊聊网页布局的那些事（一）》")]),t._v("中讨论的 css 像素的概念。")],1),t._v(" "),a("p",[t._v("以 Android 为例，在 Android 系统中，为简化为多种屏幕设计用户界面的方式，将实际屏幕尺寸和密度的范围分为：")]),t._v(" "),a("ul",[a("li",[t._v("四种通用尺寸：小、正常、大和超大")]),t._v(" "),a("li",[t._v("六种通用的密度：\n"),a("ul",[a("li",[t._v("ldpi（低）~120dpi")]),t._v(" "),a("li",[t._v("mdpi（中）~160dpi")]),t._v(" "),a("li",[t._v("hdpi（高）~240dpi")]),t._v(" "),a("li",[t._v("xhdpi（超高）~320dpi")]),t._v(" "),a("li",[t._v("xxhdpi（超超高）~480dpi")]),t._v(" "),a("li",[t._v("xxxhdpi（超超超高）~640dpi")])])])]),t._v(" "),a("p",[t._v("通用的尺寸和密度按照基线配置（即正常尺寸和 mdpi（中）密度）排列。每种通用的尺寸和密度都涵盖一个实际屏幕尺寸和密度范围。例如， 两部都报告正常屏幕尺寸的设备在手动测量时，实际屏幕尺寸和高宽比可能略有不同。类似地，对于两台报告 hdpi 屏幕密度的设备，其实际像素密度可能略有不同。 Android 将这些差异抽象概括到应用，使开发者可以提供为通用尺寸和密度设计的 UI，让系统按需要处理任何最终调整。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/images/2018/react-native-adapt/screens-ranges.png",alt:""}})]),t._v(" "),a("p",[t._v("上图说明 Android 如何将实际尺寸和密度粗略地对应到通用的尺寸和密度（数据并不精确）。")]),t._v(" "),a("p",[t._v("在为不同的屏幕尺寸设计 UI 时，开发者会发现每种设计都需要最小空间。因此，上述每种通用的屏幕尺寸都关联了系统定义的最低分辨率。这些最小尺寸以“dp”单位表示 —- 在定义布局时应使用相同的单位 —- 这样系统无需担心屏幕密度的变化。")]),t._v(" "),a("ul",[a("li",[t._v("超大屏幕至少为 960dp x 720dp")]),t._v(" "),a("li",[t._v("大屏幕至少为 640dp x 480dp")]),t._v(" "),a("li",[t._v("正常屏幕至少为 470dp x 320dp")]),t._v(" "),a("li",[t._v("小屏幕至少为 426dp x 320dp")])]),t._v(" "),a("p",[t._v("密度独立像素等于 160 dpi 屏幕上的一个物理像素，这是系统为“中”密度屏幕假设的基线密度。在运行时，系统 根据使用中屏幕的实际密度按需要以透明方式处理 dp 单位的任何缩放 。dp 单位转换为屏幕像素很简单： px = dp * (dpi / 160)。 例如，在 240 dpi 屏幕上，1 dp 等于 1.5 物理像素。在定义应用的 UI 时应始终使用 dp 单位 ，以确保在不同密度的屏幕上正常显示 UI。")]),t._v(" "),a("h3",{attrs:{id:"密度独立性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#密度独立性","aria-hidden":"true"}},[t._v("#")]),t._v(" 密度独立性")]),t._v(" "),a("p",[t._v("密度独立像素的密度独立性具体是什么含义呢？应用显示在密度不同的屏幕上时，如果它保持用户界面元素的物理尺寸（从 用户的视角）不变，便可实现“密度独立性” 。")]),t._v(" "),a("p",[t._v("保持密度独立性很重要，因为如果没有此功能，UI 元素（例如按钮）在低密度屏幕上看起来较大，在高密度屏幕上看起来较小。这些 密度相关的大小变化可能给应用布局和易用性带来问题。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/images/2018/react-native-adapt/density-test-bad.png",alt:""}})]),t._v(" "),a("p",[t._v("图 1  不支持不同密度的示例应用在低、中、高密度屏幕上的显示情况。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/images/2018/react-native-adapt/density-test-good.png",alt:""}})]),t._v(" "),a("p",[t._v("图 2 良好支持不同密度（密度独立）的示例应用在低、中、高密度屏幕上的显示情况。")]),t._v(" "),a("p",[t._v("Android 系统可帮助应用以两种方式实现密度独立性：")]),t._v(" "),a("ul",[a("li",[t._v("系统根据当前屏幕密度扩展 dp 单位数")]),t._v(" "),a("li",[t._v("系统在必要时可根据当前屏幕密度将可绘制对象资源扩展到适当的大小")])]),t._v(" "),a("p",[t._v("在图 1 中，文本视图和位图可绘制对象具有以像素（px 单位）指定的尺寸，因此视图的物理尺寸在低密度屏幕上更大，在高密度 屏幕上更小。这是因为，虽然实际屏幕尺寸可能相同，但高密度屏幕的每英寸像素更多（同样多的像素在一个更小的区域内）。在图 2 中，布局尺寸以密度独立的像素（dp 单位）指定。由于密度独立像素的基线是中密度屏幕，因此具有中密度屏幕的设备看起来与图 1 一样。但对于低密度和高密度屏幕，系统将分别增加和减少密度独立像素值，以适应屏幕。")]),t._v(" "),a("p",[t._v("大多数情况下，确保应用中的屏幕独立性很简单，只需以适当的密度独立像素（dp 单位）指定所有 布局尺寸值。系统然后根据适用于当前屏幕密度的缩放比例适当地缩放位图可绘制对象，以适当的大小显示。但位图缩放可能导致模糊，为避免这些问题，应为不同的密度提供替代的位图资源。")]),t._v(" "),a("h2",{attrs:{id:"解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案","aria-hidden":"true"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),a("p",[t._v("回到开篇提到的问题，我们如何将一个基准是 750 的稿子，适配到各个不同尺寸和密度的屏幕上呢？在设计稿中，元素的尺寸与总宽度有一个相对关系，在设备屏幕中，元素的实际宽度的 dp 数量与设备总宽度的 dp 数量有一个相对关系。我们只需要建立这两个相对关系的映射关系就可以了。")]),t._v(" "),a("p",[t._v("在 React Native 中，有如下几个模块可以帮助我们实现：")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" Dimensions"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" PixelRatio "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react-native'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("height"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" width"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Dimensions"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'window'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取窗口的宽、高度，以 dp 为单位。")]),t._v("\n\nPixelRatio"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取设备的像素密度")]),t._v("\nPixelRatio"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getFontScale")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取设备的文字缩放比率")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("在上面的代码中，我们通过 "),a("code",[t._v("Dimensions.get('window')")]),t._v(" 获取实际设备的宽度，此时，我们只需要建立一个比例关系即可确定对应于这个设备，我们实际应该设置的元素尺寸的 dp 值了。")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("BASE_LINE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("750")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设计稿是 750")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EL_WIDTH_DEVICE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" width "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("BASE_LINE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EL_WIDTH_DESIGN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("对于文字的字号大小，设计师一般不希望文字根据尺寸做过多的缩放，因此，我们需要根据系统自身定义的文字缩放比率来设置。")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("TEXT_FONT_SIZE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" PixelRatio"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getFontScale")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FONT_SIZE_DESIGN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("以上方案只是展示基本思路，毕竟每设置一个样式数字都要重新计算尺寸也十分不便，因此笔者封装了一个库 "),a("a",{attrs:{href:"https://www.npmjs.com/package/react-native-adaptive-stylesheet",target:"_blank",rel:"noopener noreferrer"}},[t._v("react-native-adaptive-stylesheet"),a("OutboundLink")],1),t._v(" 来完成缩放计算。API 与 React Native StyleSheet 的 API 一致。")]),t._v(" "),a("p",[t._v("对于位图在高清屏下存在模糊的情况，我们需要根据屏幕的像素密度提供不同尺寸的替代位图，并按需加载。屏幕像素密度可以通过 "),a("code",[t._v("PixelRatio.get()")]),t._v(" 获取。"),a("br"),t._v("\n要为不同的密度创建替代位图可绘制对象，应遵循六种通用密度之间的 3:4:6:8:12:16 缩放比率。例如，如果默认位图是对中密度屏幕使用 48x48 像素，则所有不同的尺寸应为：")]),t._v(" "),a("ul",[a("li",[t._v("36x36 (0.75x) 用于低密度")]),t._v(" "),a("li",[t._v("48x48（1.0x 基线）用于中密度")]),t._v(" "),a("li",[t._v("72x72 (1.5x) 用于高密度")]),t._v(" "),a("li",[t._v("96x96 (2.0x) 用于超高密度")]),t._v(" "),a("li",[t._v("144x144 (3.0x) 用于超超高密度")]),t._v(" "),a("li",[t._v("192x192 (4.0x) 用于超超超高密度")])]),t._v(" "),a("p",[t._v("对应的判断条件为：")]),t._v(" "),a("ul",[a("li",[t._v("PixelRatio.get() === 1\n"),a("ul",[a("li",[t._v("mdpi Android devices")])])]),t._v(" "),a("li",[t._v("PixelRatio.get() === 1.5\n"),a("ul",[a("li",[t._v("hdpi Android devices")])])]),t._v(" "),a("li",[t._v("PixelRatio.get() === 2\n"),a("ul",[a("li",[t._v("iPhone 4, 4S")]),t._v(" "),a("li",[t._v("iPhone 5, 5c, 5s")]),t._v(" "),a("li",[t._v("iPhone 6, 7, 8")]),t._v(" "),a("li",[t._v("xhdpi Android devices")])])]),t._v(" "),a("li",[t._v("PixelRatio.get() === 3\n"),a("ul",[a("li",[t._v("iPhone 6 Plus, 7 Plus, 8 Plus")]),t._v(" "),a("li",[t._v("iPhone X")]),t._v(" "),a("li",[t._v("Pixel, Pixel 2")]),t._v(" "),a("li",[t._v("xxhdpi Android devices")])])]),t._v(" "),a("li",[t._v("PixelRatio.get() === 3.5\n"),a("ul",[a("li",[t._v("Nexus 6")]),t._v(" "),a("li",[t._v("Pixel XL, Pixel 2 XL")]),t._v(" "),a("li",[t._v("xxxhdpi Android devices")])])])])])},[],!1,null,null,null);s.default=n.exports}}]);