(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{281:function(e,t,a){"use strict";a.r(t);var s=a(4),r=Object(s.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"深入-http：web-的基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入-http：web-的基础","aria-hidden":"true"}},[e._v("#")]),e._v(" 深入 HTTP：web 的基础")]),e._v(" "),a("p",[e._v("Web 浏览器、服务器和相关的 Web 应用程序都是通过 HTTP 协议相互通信的。HTTP 使用的是可靠的数据传输协议，能顾确保数据在传输过程中不会被损坏或者产生混乱。")]),e._v(" "),a("h2",{attrs:{id:"资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源","aria-hidden":"true"}},[e._v("#")]),e._v(" 资源")]),e._v(" "),a("p",[e._v("在互联网上，所有类型的内容都可以被看成资源，我们访问互联网，就是在访问各种资源，比如浏览图片、观看视频等。")]),e._v(" "),a("h3",{attrs:{id:"资源的位置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源的位置","aria-hidden":"true"}},[e._v("#")]),e._v(" 资源的位置")]),e._v(" "),a("p",[e._v("为了能找到某个资源，我们必须要知道这个资源的位置，就像我们要找一个人，就需要知道这个人的联系地址一样。HTTP 通过 URI 来确定资源的位置。URI 全称为同意资源标识符（Uniform Resource Identifier），它在世界范围内唯一标识并定位信息资源。URI 又分为 URL 和 URN 两种形式。"),a("br"),e._v("\nURL 全称是统一资源定位符，它是资源标识符最常见的形式。URL 分为三个部分：")]),e._v(" "),a("ul",[a("li",[e._v("协议头（scheme），表明访问资源所使用的协议类型，比如 http 协议。")]),e._v(" "),a("li",[e._v("服务器的地址，通常是一个域名，比如 www.google.com。")]),e._v(" "),a("li",[e._v("服务器上资源的位置，比如某个具体的路径。")])]),e._v(" "),a("p",[e._v("URN 的全称是统一资源名，作为特定内容的唯一名称使用，与资源所在的位置无关。"),a("br"),e._v("\n目前，几乎所有的 URI 都是 URL。")]),e._v(" "),a("p",[e._v("一个 URL 的完整语法由如下 9 个部分组成，但几乎没有哪个 URL 包含了所有这些组件：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("不同的协议下，URL 的组成不一样，比如：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("http://<host>:<port>/<path>?<query>#<frag>\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("或者")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ftp://<user>:<password>@<host>:<port>/<path>;<params>\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"资源的类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源的类型","aria-hidden":"true"}},[e._v("#")]),e._v(" 资源的类型")]),e._v(" "),a("p",[e._v("因为互联网上有各种类型的资源，为了能正确的标识这些资源类型，HTTP 协议给每种资源都分配了一个 MIME 类型（MIME type）。当 Web 浏览器访问服务器时，服务器会在返回的信息中为被访问的资源附加一个 MIME 类型，浏览器根据返回的 MIME 类型进行相应的处理。MIME 类型是一种文本标记，标识一种主要的对象类型和一个特定的子类型，中间由一个斜杠来分隔，比如 HTML 格式的文本文档的 MIME 类型是 text/html，JPEG 格式的图片的 MIME 类型是 image/jpeg。")]),e._v(" "),a("h2",{attrs:{id:"报文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#报文","aria-hidden":"true"}},[e._v("#")]),e._v(" 报文")]),e._v(" "),a("p",[e._v("我们每访问互联网上的一个资源都会触发一次 HTTP 请求和 HTTP 响应。HTTP 请求告诉服务器我们要访问什么样的资源，HTTP 响应告诉客户端资源的具体内容。那么，在这一来一回过程中，信息是如何传递的呢？HTTP 协议规定了特有的报文格式，客户端和服务端都按照这个格式解析 HTTP 报文读取信息。"),a("br"),e._v("\nHTTP 的请求报文格式如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<method> <request-URL> <version>\n<headers>\n\n<entity-body>\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("HTTP 的响应报文格式如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<version> <status> <reason-phrase>\n<headers>\n\n<entity-body>\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("ul",[a("li",[e._v("method 表示客户端希望服务器对资源执行的操作，比如 GET、PUT、POST、DELETE、HEAD、OPTIONS 等。")]),e._v(" "),a("li",[e._v("request-URL 表示资源的具体位置。")]),e._v(" "),a("li",[e._v("version 表示使用的协议版本，格式为 "),a("code",[e._v("HTTP/<major>.<minor>")]),e._v("。")]),e._v(" "),a("li",[e._v("headers 表示首部，包含了资源的额外信息。以"),a("code",[e._v("首部名称:首部值")]),e._v("为格式。")]),e._v(" "),a("li",[e._v("status 表示状态码，100~199 用于信息提示，200~299 表示成功，300~399 表示重定向，400~499 表示客户端错误，500~599 表示服务端错误。")]),e._v(" "),a("li",[e._v("reason-phrase 表示响应的原因短信。")]),e._v(" "),a("li",[e._v("entity-body 是由任意数据组成的数据块。")])]),e._v(" "),a("p",[e._v("在上面的报文中，每一个部分都由一个 CRLF（回车换行）来分割，同时，headers 和 entity-body 之间还需要一个空行做分割。\n首部可大致分为五类：通用首部、请求首部、响应首部、实体首部和扩展首部。具体信息可以"),a("a",{attrs:{href:"https://www.w3.org/Protocols/rfc2616/rfc2616.txt",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考"),a("OutboundLink")],1),e._v("。")]),e._v(" "),a("h2",{attrs:{id:"连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连接","aria-hidden":"true"}},[e._v("#")]),e._v(" 连接")]),e._v(" "),a("p",[e._v("HTTP 协议属于应用层协议，HTTP 报文是通过 TCP/IP 的报文在互联网上传输的（HTTPS 会在 HTTP 和 TCP 之间多一层 SSL/TSL 层）。一个 HTTP 连接就是一个 TCP 连接。TCP 协议是一个可靠传输协议，通过 TCP 协议传输的数据不会出现数据丢失、乱序的情况。但是 TCP 协议也有一些弱点，比如连接的"),a("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE",target:"_blank",rel:"noopener noreferrer"}},[e._v("握手时延问题"),a("OutboundLink")],1),e._v("、"),a("a",{attrs:{href:"https://zh.wikipedia.org/zh-hans/%E6%85%A2%E5%90%AF%E5%8A%A8",target:"_blank",rel:"noopener noreferrer"}},[e._v("慢启动问题"),a("OutboundLink")],1),e._v("等。这些问题或多或少都会影响到 HTTP 的数据传输性能。")]),e._v(" "),a("p",[e._v("HTTP 协议做了一些连接优化处理，比如通过 "),a("code",[e._v("Connection")]),e._v(" 首部控制连接的关闭以及是否为长连接。"),a("code",[e._v("Connection")]),e._v(" 首部可以承载三种不同类型的标签：")]),e._v(" "),a("ul",[a("li",[e._v("HTTP 首部字段名，列出了只与此连接有关的首部")]),e._v(" "),a("li",[e._v("任意标签值，用于描述此连接的非标准选项")]),e._v(" "),a("li",[e._v("值 close，说明操作完成之后需要关闭此永久连接")])]),e._v(" "),a("p",[e._v("比较常见的是 "),a("code",[e._v("Connection: Keep-Alive")]),e._v(" 和 "),a("code",[e._v("Connection: close")]),e._v("。当客户端发送请求时，在请求头中增加 "),a("code",[e._v("Connection: Keep-Alive")]),e._v(" 首部说明，那么在服务端接收到该请求时，如果服务端支持长连接，那么服务端会在响应头里也增加 "),a("code",[e._v("Connection: Keep-Alive")]),e._v(" 首部说明，并保持 TCP 连接。客户端在接到 "),a("code",[e._v("Connection: Keep-Alive")]),e._v(" 响应后，也保持 TCP 连接。这样，后续的请求会重用 TCP 连接从而避免了三次握手等问题。当长连接超时或者服务端不支持长连接时，服务端在响应头中增加 "),a("code",[e._v("Connection: close")]),e._v(" 首部说明，表示连接已经关闭。需要注意的是，"),a("code",[e._v("Connection")]),e._v(" 首部是逐跳应用的，因此在客户端和服务端之间的代理服务器在转发请求时需要特殊处理 "),a("code",[e._v("Connection")]),e._v(" 首部。")]),e._v(" "),a("p",[e._v("除了重用连接优化数据传输以外，客户端通常还支持并发请求，实际就是并行建立 TCP 连接，以提升性能。并发数量因客户端而异。")])])},[],!1,null,null,null);t.default=r.exports}}]);