(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{272:function(a,s,t){"use strict";t.r(s);var e=t(4),v=Object(e.a)({},function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"前端安全之跨站脚本攻击（xss）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端安全之跨站脚本攻击（xss）","aria-hidden":"true"}},[a._v("#")]),a._v(" 前端安全之跨站脚本攻击（XSS）")]),a._v(" "),t("p",[a._v("跨站脚本攻击（Cross Site Script，为了与层叠样式表的缩写作区分，简写成 XSS），通常指黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。")]),a._v(" "),t("h2",{attrs:{id:"xss-攻击的类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#xss-攻击的类型","aria-hidden":"true"}},[a._v("#")]),a._v(" XSS 攻击的类型")]),a._v(" "),t("p",[a._v("XSS 根据效果的不同可以分成三类：反射型 XSS、存储型 XSS、DOM Based XSS。")]),a._v(" "),t("h3",{attrs:{id:"反射型-xss"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#反射型-xss","aria-hidden":"true"}},[a._v("#")]),a._v(" 反射型 XSS")]),a._v(" "),t("p",[a._v("反射型 XSS 只是简单地把用户输入的数据“反射”给浏览器。也就是说，黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。")]),a._v(" "),t("p",[a._v("很多网站都有搜索框，比如我们访问淘宝网首页 "),t("code",[a._v("www.taobao.com")]),a._v("，在搜索框中输入搜索信息 "),t("code",[a._v("ddddd")]),a._v("，此时会跳转都一个搜索结果页，链接如下，搜索参数被附加在了 URL 参数中。")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("https://s.taobao.com/search?q=ddddd&imgfile=&commend=all&ssid=s5-e&search_type=item&sourceId=tb.index&spm=a21bo.2017.201856-taobao-item.1&ie=utf8&initiative_id=tbindexz_20170306\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("很多时候，服务器会根据请求的参数值构造不同的 HTML 返回。此时，我们输入的参数可能出现在返回的 HTML (可能是 JS , HTML 某元素的内容或者属性)中，如果我们将参数改成可以在浏览器中被解释执行的东西,就形成了反射型XSS。")]),a._v(" "),t("p",[a._v("攻击者通常会分析被攻击的网站，找到这样的漏洞，然后构造恶意链接，比如在参数中加入 "),t("code",[a._v("<script>")]),a._v(" 标签引用恶意脚本，发送给其他人。当恶意链接被打开时，恶意代码就会被 HTML 解析、下载并执行。由于反射型 XSS 的特点是非持久化的，必须用户点击带有特定参数的链接才能引起，因此也叫做“非持久型 XSS（Non-persistent XSS）”。")]),a._v(" "),t("h3",{attrs:{id:"存储型-xss"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存储型-xss","aria-hidden":"true"}},[a._v("#")]),a._v(" 存储型 XSS")]),a._v(" "),t("p",[a._v("存储型 XSS 会把用户输入的数据“存储”在服务端。这种 XSS 具有很强的稳定性。")]),a._v(" "),t("p",[a._v("比如，黑客在某个论坛写下一个包含恶意 JS 代码的文章，文章发表后，所有访问该文章的用户都会在他们的浏览器中执行这段恶意的 JS 代码。黑客把恶意的代码保存在服务端，所以这种 XSS 攻击就叫做 “存储型 XSS”，也叫“持久型 XSS（Persistent XSS）”。")]),a._v(" "),t("p",[a._v("存储型 XSS 有时候会造成大规模的 XSS 蠕虫攻击。比如获取到用户登录信息时，利用获取到的用户登录信息发布新的恶意代码，比如上例中发布新的文章，此时，攻击范围将会指数级的扩大。")]),a._v(" "),t("h3",{attrs:{id:"dom-based-xss"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dom-based-xss","aria-hidden":"true"}},[a._v("#")]),a._v(" DOM Based XSS")]),a._v(" "),t("p",[a._v("通过修改页面 DOM 节点形成的 XSS，被称为 DOM Based XSS。DOM Based XSS 在攻击效果上也是反射型 XSS，之所以单独划分出来，是因为 DOM Based XSS 的形成原因比较特别。前面两种 XSS 攻击都是需要在服务端拼接用户输入作为 HTML 输出到页面上，而 DOM Based XSS 则是完全在浏览器端完成攻击，利用的是浏览器解析机制导致的漏洞。")]),a._v(" "),t("p",[a._v("理解 DOM Based XSS 非常简单，参照反射型 XSS 的例子，在构造攻击参数时，我们不直接引入 "),t("code",[a._v("<script>")]),a._v(" 标签，而是通过修改页面上其他 DOM 元素的属性来完成恶意代码的引入。")]),a._v(" "),t("p",[a._v("比如某个网站将用户输入的内容做如下展示：")]),a._v(" "),t("div",{staticClass:"language-html line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("div")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v('搜索"'),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("span")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("dddd"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("span")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v('"的结果为：'),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("div")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("构造如下参数 "),t("code",[a._v('</span><img src="#" onerror="eval(\'some evil js code\')" /><span>')]),a._v(" 就可以完成攻击行为。")]),a._v(" "),t("h2",{attrs:{id:"如何防御"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何防御","aria-hidden":"true"}},[a._v("#")]),a._v(" 如何防御")]),a._v(" "),t("p",[a._v("XSS 本质是一种 “HTML 注入”，用户的数据被当成 HTML 代码的一部分来执行，从而混淆了原来的语义，产生了新的语义。因此，针对 XSS 的防御也应该聚焦于用户的输入以及用户数据的输出上面。")]),a._v(" "),t("h3",{attrs:{id:"输入检查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#输入检查","aria-hidden":"true"}},[a._v("#")]),a._v(" 输入检查")]),a._v(" "),t("p",[a._v('黑客在进行注入攻击时，通常需要构造一些特殊字符，比如 ">"、"<" 等，这些符号用户几乎用不到，因此，可以通过白名单的方式进行输入检查，将一些特殊字符过滤掉。比如用户名只允许包含数字、字母和下划线。')]),a._v(" "),t("blockquote",[t("p",[a._v("需要注意的一点是，输入检查的逻辑必须要放在服务端进行，客户端的输入检查容易被绕过。")])]),a._v(" "),t("h3",{attrs:{id:"输出检查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#输出检查","aria-hidden":"true"}},[a._v("#")]),a._v(" 输出检查")]),a._v(" "),t("p",[a._v("一般来说，除了富文本以外，在变量输出到 HTML 页面时，可以编码或转移的方式来防御 XSS 攻击。业界有很多已经实现了的安全编码函数，这些安全编码函数通常会将 "),t("code",[a._v("&")]),a._v("、"),t("code",[a._v("<")]),a._v("、"),t("code",[a._v(">")]),a._v("、"),t("code",[a._v('"')]),a._v("、"),t("code",[a._v("'")]),a._v("、"),t("code",[a._v("/")]),a._v(" 等符号转译成对应的 HTML 实体"),t("code",[a._v("&amp;")]),a._v("、"),t("code",[a._v("&lt;")]),a._v("、"),t("code",[a._v("&gt;")]),a._v("、"),t("code",[a._v("&quot;")]),a._v("、"),t("code",[a._v("&#x27;")]),a._v("、"),t("code",[a._v("&#x2f")]),a._v(" 等。随着技术的进步以及安全意识的提升，每个框架都有自己的编码函数的实现，框架使用者可以在框架中使用对应的实现而不需要自己实现。")]),a._v(" "),t("p",[a._v("用户输入的来源往往可以确定的固定在系统的少数几个地方，但是输出通常不固定。比如， 可以在 HTML 标签中输出，可以在 HTML 的属性中输出，可以在 "),t("code",[a._v("<script>")]),a._v(" 标签中输出，也可以在事件中输出，在 URL 地址中输出，甚至可以在 CSS 中输出。 每种输出方式的处理不同，需要开发者针对特定的场景做详细的考量处理。")]),a._v(" "),t("h3",{attrs:{id:"富文本处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#富文本处理","aria-hidden":"true"}},[a._v("#")]),a._v(" 富文本处理")]),a._v(" "),t("p",[a._v("富文本往往出现在论坛等网站中。由于富文本标签复杂，比如一个用户在论坛里发帖，帖子的内容要有图片、视频、表格等，如何防御基于富文本的 XSS 攻击就变得异常复杂。其实可以将思路转回到输入检查上来，可以利用白名单的方式，限制用户输入的标签的种类。比如限制比较危险的 "),t("code",[a._v("<iframe>")]),a._v("、"),t("code",[a._v("<base>")]),a._v("、"),t("code",[a._v("<script>")]),a._v("、"),t("code",[a._v("<form>")]),a._v(" 等标签，而只允许 "),t("code",[a._v("<a>")]),a._v("、"),t("code",[a._v("<div>")]),a._v("、"),t("code",[a._v("<img>")]),a._v(" 等比较安全的标签。")]),a._v(" "),t("h3",{attrs:{id:"防御-dom-based-xss-攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#防御-dom-based-xss-攻击","aria-hidden":"true"}},[a._v("#")]),a._v(" 防御 DOM Based XSS 攻击")]),a._v(" "),t("p",[a._v("事实上，DOM Based XSS 是从 JS 中输出数据到 HTML 页面里面，前面提到的输出检查，很多都是针对从服务器应用直接输出到 HTML 页面的 XSS 漏洞，并不适用于 DOM Based XSS 攻击。因为通常服务端编码后的数据在浏览器首次解析时已经被解析并转义成原始数据，此时再通过 JS 修改 DOM 数据还是会形成 XSS 注入攻击。"),t("br"),a._v("\n其实解决方法也非常简单，只需要保证两个原则就可以避免此类 XSS 攻击。")]),a._v(" "),t("ul",[t("li",[a._v("输出到 HTML 内容、属性的数据要通过 HTML 实体再编码一次")]),a._v(" "),t("li",[a._v("输出到 HTML 事件和 "),t("code",[a._v("<script>")]),a._v(" 标签内容的数据需要再通过 JS 编码一次")])]),a._v(" "),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结","aria-hidden":"true"}},[a._v("#")]),a._v(" 小结")]),a._v(" "),t("p",[a._v("XSS 本质上是一种 “HTML 注入” 型攻击。XSS 漏洞虽然复杂，但却是可以彻底解决的。在解决 XSS 问题时，需要深入理解 XSS 攻击的原理，并根据不同的场景采取不同的方法。")])])},[],!1,null,null,null);s.default=v.exports}}]);