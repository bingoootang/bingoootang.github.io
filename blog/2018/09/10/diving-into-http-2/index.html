<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入 HTTP：缓存 | Bingooo.Tang 的日志</title>
    <meta name="description" content="深入 HTTP，缓存">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="preload" href="/assets/css/0.styles.45fd1eb4.css" as="style"><link rel="preload" href="/assets/js/app.1a92a99b.js" as="script"><link rel="preload" href="/assets/js/2.4bb95436.js" as="script"><link rel="preload" href="/assets/js/37.839e7d79.js" as="script"><link rel="preload" href="/assets/js/9.60a9ad14.js" as="script"><link rel="prefetch" href="/assets/js/10.ff19f3cc.js"><link rel="prefetch" href="/assets/js/11.e260adce.js"><link rel="prefetch" href="/assets/js/12.e1d4dc76.js"><link rel="prefetch" href="/assets/js/13.3780b65b.js"><link rel="prefetch" href="/assets/js/14.821eca39.js"><link rel="prefetch" href="/assets/js/15.947a489c.js"><link rel="prefetch" href="/assets/js/16.31117fc6.js"><link rel="prefetch" href="/assets/js/17.aa761a41.js"><link rel="prefetch" href="/assets/js/18.38e91cd9.js"><link rel="prefetch" href="/assets/js/19.2f0ddeb0.js"><link rel="prefetch" href="/assets/js/20.98a05b39.js"><link rel="prefetch" href="/assets/js/21.12bee07e.js"><link rel="prefetch" href="/assets/js/22.825b5c65.js"><link rel="prefetch" href="/assets/js/23.5a7523f8.js"><link rel="prefetch" href="/assets/js/24.d4db672e.js"><link rel="prefetch" href="/assets/js/25.9dc639ba.js"><link rel="prefetch" href="/assets/js/26.bb89ef52.js"><link rel="prefetch" href="/assets/js/27.9b952333.js"><link rel="prefetch" href="/assets/js/28.36b12119.js"><link rel="prefetch" href="/assets/js/29.b3fc89ab.js"><link rel="prefetch" href="/assets/js/3.914428ae.js"><link rel="prefetch" href="/assets/js/30.8403f552.js"><link rel="prefetch" href="/assets/js/31.3a71fc7c.js"><link rel="prefetch" href="/assets/js/32.f63547d0.js"><link rel="prefetch" href="/assets/js/33.30c37fb4.js"><link rel="prefetch" href="/assets/js/34.b1e97f3f.js"><link rel="prefetch" href="/assets/js/35.ab2a7a8c.js"><link rel="prefetch" href="/assets/js/36.5d422d5b.js"><link rel="prefetch" href="/assets/js/38.72e8bf2f.js"><link rel="prefetch" href="/assets/js/39.9a05368b.js"><link rel="prefetch" href="/assets/js/4.5c559b86.js"><link rel="prefetch" href="/assets/js/40.a8400673.js"><link rel="prefetch" href="/assets/js/41.ead2592b.js"><link rel="prefetch" href="/assets/js/42.2b99ba39.js"><link rel="prefetch" href="/assets/js/43.340f4287.js"><link rel="prefetch" href="/assets/js/44.6bf6391c.js"><link rel="prefetch" href="/assets/js/45.c33e2690.js"><link rel="prefetch" href="/assets/js/46.acfb4c4c.js"><link rel="prefetch" href="/assets/js/47.0d284677.js"><link rel="prefetch" href="/assets/js/48.7e5faf9d.js"><link rel="prefetch" href="/assets/js/49.70243ee5.js"><link rel="prefetch" href="/assets/js/5.4f064dd5.js"><link rel="prefetch" href="/assets/js/50.a70d1e3a.js"><link rel="prefetch" href="/assets/js/51.54705e9f.js"><link rel="prefetch" href="/assets/js/52.5e8b3d7e.js"><link rel="prefetch" href="/assets/js/53.03656bc8.js"><link rel="prefetch" href="/assets/js/54.d3b3024e.js"><link rel="prefetch" href="/assets/js/55.b8b66fcf.js"><link rel="prefetch" href="/assets/js/56.bcc27a01.js"><link rel="prefetch" href="/assets/js/57.dd12e611.js"><link rel="prefetch" href="/assets/js/6.8113e0b5.js"><link rel="prefetch" href="/assets/js/7.222800b2.js"><link rel="prefetch" href="/assets/js/8.84f16d44.js">
    <link rel="stylesheet" href="/assets/css/0.styles.45fd1eb4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Bingooo.Tang 的日志</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">博客</a></div><div class="nav-item"><a href="/tutorials/" class="nav-link">教程</a></div><div class="nav-item"><a href="/tools/" class="nav-link">工具</a></div> <a href="https://github.com/bingoootang" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">博客</a></div><div class="nav-item"><a href="/tutorials/" class="nav-link">教程</a></div><div class="nav-item"><a href="/tools/" class="nav-link">工具</a></div> <a href="https://github.com/bingoootang" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <!----> </aside> <main class="page"> <div class="content default"><h1 id="深入-http：缓存"><a href="#深入-http：缓存" aria-hidden="true" class="header-anchor">#</a> 深入 HTTP：缓存</h1> <p>缓存是一个老生常谈的问题，重要性不言而喻，HTTP 协议中规定了很多请求头和响应头来控制缓存。也因为如此，很多人无法分清某个头部的作用和优先级。本文尝试做一下梳理和总结。</p> <h2 id="经典-get-请求过程"><a href="#经典-get-请求过程" aria-hidden="true" class="header-anchor">#</a> 经典 GET 请求过程</h2> <p>先看一个经典的 GET 请求的处理过程，如下图：<br> <img src="/images/2018/diving-into-http-2/get.jpg" alt="IMAGE"><br>
当一个请求达到时，浏览器（为方便叙述，已浏览器为例）先检查被访问的资源是否已被缓存，如果未被缓存（缓存未命中 cache miss），则将请求转发给原始服务器。如果被缓存（缓存命中，cache hit），则会检查缓存是否足够新鲜。如果缓存的副本足够新鲜，则直接将副本返回给客户端，否则会向服务端发起新鲜度验证（revalidation）。如果发现与服务端文件一致，则将本地缓存副本返回给客户端，否则将请求转发给原始服务器。</p> <p>在这个过程中，由缓存提供服务的请求所在的比例称为缓存命中率（cache hit rat）。这种描述方式只能描述请求级别的命中情况，无法体现具体有多少流量来自缓存。比如一个访问频次很低，尺寸很大的文件，如果以该命中率来描述的话，命中率非常低。但是这个文件却占据了绝大多数的访问流量。因此还需要另一个命中率指标来描述，那就是字节命中率（byte hit rate）。字节命中率表示的是缓存提供的字节在传输的所有字节中所占的比例。下面章节中服务器再验证的两种策略即是这两种命中率的具体使用。</p> <h2 id="缓存机制"><a href="#缓存机制" aria-hidden="true" class="header-anchor">#</a> 缓存机制</h2> <p>上图中，HTTP 通过一些简单的机制在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。这些机制可以分为两个部分，第一部分称为文档过期（document expiration），第二部分称为服务端再验证（server revalidation。</p> <h3 id="文档过期"><a href="#文档过期" aria-hidden="true" class="header-anchor">#</a> 文档过期</h3> <p>通过 <code>Cache-Control:max-age</code> 首部和 <code>Expires</code> 首部，HTTP 让原始服务器向每个文档附加一个“过期日期”。在缓存文档过期之前，缓存可以以任意频次使用这些副本，而无需与服务端联系。<br> <code>Expires</code> 首部与 <code>Cache-Control:max-age</code> 首部本质上是一样的，区别是 <code>Expires</code> 是 HTTP/1.0 协议规定的首部，且首部取值为一个绝对时间，在这个时间之后缓存失效；<code>Cache-Control:max-age</code> 是 HTTP/1.1 协议规定的首部，且首部取值是一个相对时间，单位为秒。</p> <h3 id="服务器再验证"><a href="#服务器再验证" aria-hidden="true" class="header-anchor">#</a> 服务器再验证</h3> <p>HTTP 定义了 5 个条件请求首部来完成服务器再验证。</p> <ul><li>If-Modified-Since</li> <li>If-None-Match</li> <li>If-Unmodified-Since</li> <li>If-Range</li> <li>If-Match</li></ul> <p>其中最有用的是 <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 两个首部。</p> <h4 id="if-modified-since-date-再验证"><a href="#if-modified-since-date-再验证" aria-hidden="true" class="header-anchor">#</a> <code>If-Modified-Since: Date</code> 再验证</h4> <p><code>If-Modified-Since: Date</code> 再验证请求工作方式如下：</p> <ul><li>如果自指定日期后，文档被修改了，If-Modified-Since 条件为真，GET 请求就会执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息以外，还包含了一个新的过期日期。</li> <li>入股自指定日期后，文档没有被修改过，条件就为假，会向客户端返回一个小的 304 Not Modified 响应报文，为了提高有效性，一般会发送一个新的过期日期，不会返回文档的主体。</li></ul> <p>If-Modified-Since 请求首部通常与 Last-Modified 服务器响应首部配合工作。原始服务器会将最后的修改日期附加到文档上去。当缓存要对已缓存的文档进行再验证时，就会包含一个 If-Modified-SinceIf-Modified-Since 首部，其中携带有最后修改已缓存副本额日期：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>If-Modified-Since: &lt;cached last-modified date&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="if-none-match-etag-实体标签验证"><a href="#if-none-match-etag-实体标签验证" aria-hidden="true" class="header-anchor">#</a> <code>If-None-Match: etag</code> 实体标签验证</h4> <p>有些情况下，<code>If-Modified-Since: Date</code> 再验证无法很好的解决缓存问题。比如一个被周期性复写的文件，但是文件的内容往往是一样的。这种情况下，就需要借助实体标签（Etag）验证了。实体标签就是“版本标识符”，是附加到文档上的任意标签（引用字符串），可能包含了文档的序列号或版本名，或者是文档内容的校验信息。<br> <code>If-None-Match: etag</code> 实体标签验证的工作过程与 <code>If-Modified-Since: Date</code> 再验证的工作过程基本一致，不同的是，服务器会在响应中附加一个 <code>Etag</code> 响应头。当缓存要对已缓存的文档进行再验证时，就会将这个 etag 放到 If-None-Match 请求头中去。</p> <h2 id="服务器控制缓存的能力"><a href="#服务器控制缓存的能力" aria-hidden="true" class="header-anchor">#</a> 服务器控制缓存的能力</h2> <p>服务器也可以通过如下方式控制缓存，优先级一次递减：</p> <ul><li>Cache-Control: no-store  禁止缓存对响应进行复制。</li> <li>Cache-Control: no-cache/ Pragma: no-cache  缓存可以复制响应，但是在与原始服务器进行新鲜度再验证之前不能将其提供给客户端。Pramga: no-cache 为了兼容 HTTP/1.0，优先级低于 Cache-Control: no-cache。</li> <li>Cache-Control: must-revalidate  在事前没有跟原始服务器进行再验证的情况下，缓存不能提供缓存副本。</li> <li>Cache-Control: max-age  max-age 指定的秒数内有效。max-age 为零时，不可缓存。</li> <li>Expires: Date  在实际的绝对日期之前有效。</li></ul> <h2 id="客户端的新鲜度控制"><a href="#客户端的新鲜度控制" aria-hidden="true" class="header-anchor">#</a> 客户端的新鲜度控制</h2> <p>客户端通过 <code>Cache-Control</code> 请求首部来强化或放松对过期时间的限制。</p> <ul><li>Cache-Control: max-stale=&lt; s &gt;  缓存可以随意提供副本，如果指定的秒数，那么在这段时间内，文档不能过期。</li> <li>Cache-Control: min-fresh=&lt; s &gt;  至少在未来&lt; s &gt;秒内文档保持新鲜。</li> <li>Cache-Control: max-age=&lt; s &gt;  缓存无法返回缓存时间超过&lt; s &gt;的文档。如果与 max-stale 通用，max-stale 优先级更高。</li> <li>Cache-Control: no-cache/Pragma: no-cache  除非进行了再验证，否则客户端不接受已缓存的资源。</li> <li>Cache-Control: no-store  缓存应该删除本地缓存副本，使用原始服务器响应。</li> <li>Cache-Control: only-if-cache  只有当缓存中有副本存在时，客户端才会获取一份副本。</li></ul> <h2 id="小结"><a href="#小结" aria-hidden="true" class="header-anchor">#</a> 小结</h2> <p>合理的缓存策略可以帮助我们减少冗余数据传输，节省带宽，同时加快响应速度。不当的缓存策略也可能导致客户端一直使用过期的缓存副本，无法得到及时更新。因此，在搞清楚缓存机制后，根据业务需要进行合理配置才是有效使用缓存的正确姿势。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">5/13/2019, 3:05:16 PM</span></div></footer> <!----> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.1a92a99b.js" defer></script><script src="/assets/js/2.4bb95436.js" defer></script><script src="/assets/js/37.839e7d79.js" defer></script><script src="/assets/js/9.60a9ad14.js" defer></script>
  </body>
</html>
